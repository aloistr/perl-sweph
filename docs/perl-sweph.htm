<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a>
    <ul>
      <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
      <li><a href="#Simple-example">Simple example</a></li>
      <li><a href="#Testing-functions-from-command-line">Testing functions from command line</a></li>
      <li><a href="#EXPORT">EXPORT</a></li>
    </ul>
  </li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#ref-swe_version">$ref = swe_version();</a>
        <ul>
          <li><a href="#Output:-ref-hash-reference-which-contains">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#lpath-swe_get_library_path">$lpath = swe_get_library_path();</a></li>
    </ul>
  </li>
  <li><a href="#Opening-and-Closing-the-Ephemeris">Opening and Closing the Ephemeris</a>
    <ul>
      <li><a href="#swe_set_ephe_path-path">swe_set_ephe_path($path);</a>
        <ul>
          <li><a href="#Input:-path-Path-of-the-ephemeris-files">Input: $path Path of the ephemeris files</a></li>
        </ul>
      </li>
      <li><a href="#swe_set_jpl_file-filename">swe_set_jpl_file($filename);</a></li>
      <li><a href="#swe_close">swe_close( );</a></li>
    </ul>
  </li>
  <li><a href="#Julian-Day-Number-and-Calendar-Conversions">Julian Day Number and Calendar Conversions</a>
    <ul>
      <li><a href="#tjd-swe_julday-year-month-day-hour-calflag">$tjd = swe_julday($year, $month, $day, $hour, $calflag);</a></li>
      <li><a href="#ref-swe_revjul-tjd-calflag">$ref = swe_revjul($tjd, $calflag);</a>
        <ul>
          <li><a href="#Output:-ref-hash-reference-which-contains1">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#ref-swe_utc_time_zone-year-month-day-hour-min-sec-dtimezone">$ref = swe_utc_time_zone($year, $month, $day, $hour, $min, $sec, $dtimezone);</a>
        <ul>
          <li><a href="#input">input</a></li>
          <li><a href="#Output:-ref-hash-reference-which-contains2">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#ref-swe_utc_to_jd-iyar-imon-iday-ihou-imin-dsec-calflag">$ref = swe_utc_to_jd($iyar, $imon, $iday, $ihou, $imin, $dsec, $calflag);</a>
        <ul>
          <li><a href="#Output:-ref-hash-reference-which-contains3">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#ref-swe_jdet_to_utc-tjd-calflag">$ref = swe_jdet_to_utc($tjd, $calflag);</a>
        <ul>
          <li><a href="#Output:-ref-hash-reference-which-contains4">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#ref-swe_jdut1_to_utc-tjd-calflag">$ref = swe_jdut1_to_utc($tjd, $calflag);</a>
        <ul>
          <li><a href="#Output:-ref-hash-reference-which-contains5">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#dow-swe_day_of_week-tjd">$dow = swe_day_of_week($tjd);</a></li>
    </ul>
  </li>
  <li><a href="#Delta-T-and-Tidal-Acceleration-of-the-Moon">Delta T and Tidal Acceleration of the Moon</a>
    <ul>
      <li><a href="#dt-swe_deltat-tjd_ut">$dt = swe_deltat($tjd_ut);</a>
        <ul>
          <li><a href="#Input:-tjd_ut-Julian-day-number-Universal-Time">Input: $tjd_ut Julian day number, Universal Time</a></li>
          <li><a href="#Output:-dt-Delta-T-in-days">Output: $dt Delta T in days</a></li>
        </ul>
      </li>
      <li><a href="#ref-swe_deltat_ex-tjd_ut-ephe_flag">$ref = swe_deltat_ex($tjd_ut, $ephe_flag);</a>
        <ul>
          <li><a href="#Input">Input:</a></li>
          <li><a href="#Output">Output:</a></li>
        </ul>
      </li>
      <li><a href="#swe_set_delta_t_userdef-dt">swe_set_delta_t_userdef($dt);</a></li>
      <li><a href="#tacc-swe_get_tid_acc">$tacc = swe_get_tid_acc( );</a></li>
      <li><a href="#swe_set_tid_acc-tacc">swe_set_tid_acc($tacc);</a></li>
    </ul>
  </li>
  <li><a href="#Sidereal-Time">Sidereal Time</a>
    <ul>
      <li><a href="#tsid-swe_sidtime-tjd_ut">$tsid = swe_sidtime($tjd_ut);</a></li>
      <li><a href="#tsid-swe_sidtime0-tjd_ut-eps-nut">$tsid = swe_sidtime0($tjd_ut, $eps, $nut);</a>
        <ul>
          <li><a href="#Input1">Input:</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Time-Equation">Time Equation</a>
    <ul>
      <li><a href="#ref-swe_time_equ-tjd_ut">$ref = swe_time_equ($tjd_ut);</a>
        <ul>
          <li><a href="#Input:-tjd_ut-Julian-day-number-Universal-Time1">Input: $tjd_ut Julian day number, Universal Time</a></li>
          <li><a href="#Output:-ref-hash-reference-which-contains6">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#Conversions-between-LMT-and-LAT-Local-Mean-Apparent-Time">Conversions between LMT and LAT (Local Mean/Apparent Time)</a></li>
      <li><a href="#ref-swe_lmt_to_lat-tjd_lmt-geolon">$ref = swe_lmt_to_lat($tjd_lmt, $geolon);</a>
        <ul>
          <li><a href="#Input2">Input:</a></li>
          <li><a href="#Output:-ref-hash-reference-which-contains7">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#ref-swe_lat_to_lmt-tjd_lat-geolon">$ref = swe_lat_to_lmt($tjd_lat, $geolon);</a>
        <ul>
          <li><a href="#Input3">Input:</a></li>
          <li><a href="#Output:-ref-hash-reference-which-contains8">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Positions-of-Celestial-Bodies">Positions of Celestial Bodies</a>
    <ul>
      <li><a href="#ref-swe_calc-tjd_et-ipl-iflag">$ref = swe_calc($tjd_et, $ipl, $iflag);</a>
        <ul>
          <li><a href="#Input4">Input:</a></li>
          <li><a href="#Output:-ref-hash-reference-which-contains9">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#ref-swe_calc_ut-tjd_ut-ipl-iflag">$ref = swe_calc_ut($tjd_ut, $ipl, $iflag);</a>
        <ul>
          <li><a href="#Input5">Input:</a></li>
          <li><a href="#Output:-ref-hash-reference-which-contains10">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#ref-swe_calc_pctr-tjd_et-ipl-iplctr-iflag">$ref = swe_calc_pctr($tjd_et, $ipl, $iplctr, $iflag);</a>
        <ul>
          <li><a href="#Input6">Input:</a></li>
          <li><a href="#Output:-ref-hash-reference-which-contains11">Output: $ref hash reference, which contains:</a></li>
        </ul>
      </li>
      <li><a href="#Planet-numbers-ipl-for-swe_calc-function-family">Planet numbers ($ipl) for swe_calc() function family</a></li>
      <li><a href="#Calculation-flags-iflag-for-swe_calc">Calculation flags ($iflag) for swe_calc( )</a></li>
      <li><a href="#swe_set_topo-geolon-geolat-geoalt">swe_set_topo($geolon, $geolat, $geoalt);</a></li>
      <li><a href="#swe_set_ayanamsa-isidmode-t0-ayan_t0">swe_set_ayanamsa($isidmode, t0, ayan_t0);</a></li>
      <li><a href="#daya-swe_get_ayanamsa-tjd_et">$daya = swe_get_ayanamsa($tjd_et);</a></li>
      <li><a href="#daya-swe_get_ayanamsa_ut-tjd_ut">$daya = swe_get_ayanamsa_ut($tjd_ut);</a></li>
      <li><a href="#ref-swe_get_ayanamsa_ex-tjd_et-epheflag">$ref = swe_get_ayanamsa_ex($tjd_et, epheflag);</a></li>
      <li><a href="#ref-swe_get_ayanamsa_ex_ut-tjd_ut-epheflag">$ref = swe_get_ayanamsa_ex_ut($tjd_ut, epheflag);</a></li>
      <li><a href="#ayanam-swe_get_ayanamsa_name-isidmode">$ayanam = swe_get_ayanamsa_name($isidmode);</a></li>
    </ul>
  </li>
  <li><a href="#Positions-of-Fixed-Stars">Positions of Fixed Stars</a>
    <ul>
      <li><a href="#ref-swe_fixstar-star-tjd_et-iflag">$ref = swe_fixstar($star, $tjd_et, $iflag);</a></li>
      <li><a href="#ref-swe_fixstar2-star-tjd_et-iflag">$ref = swe_fixstar2($star, $tjd_et, $iflag);</a></li>
      <li><a href="#ref-swe_fixstar_ut-star-tjd_ut-iflag">$ref = swe_fixstar_ut($star, $tjd_ut, $iflag);</a></li>
      <li><a href="#ref-swe_fixstar2_ut-star-tjd_ut-iflag">$ref = swe_fixstar2_ut($star, $tjd_ut, $iflag);</a></li>
    </ul>
  </li>
  <li><a href="#Name-Magnitude-Phase-Elongation-Disc-Diameter-etc">Name, Magnitude, Phase, Elongation, Disc Diameter, etc.</a>
    <ul>
      <li><a href="#name-swe_get_planet_name-ipl">$name = swe_get_planet_name($ipl);</a></li>
      <li><a href="#ref-swe_pheno-tjd_et-ipl-iflag">$ref = swe_pheno($tjd_et, $ipl, $iflag);</a></li>
      <li><a href="#ref-swe_pheno-tjd_et-ipl-iflag1">$ref = swe_pheno($tjd_et, $ipl, $iflag);</a></li>
      <li><a href="#ref-swe_fixstar_mag-star-head2-ref-swe_fixstar2_mag-star">$ref = swe_fixstar_mag($star); =head2 $ref = swe_fixstar2_mag($star);</a></li>
    </ul>
  </li>
  <li><a href="#Rising-Setting-and-Meridian-Transits">Rising, Setting and Meridian Transits</a>
    <ul>
      <li><a href="#ref-swe_rise_trans-tjd_ut-ipl-star-epheflag-rsmi-geopos-atpress-attemp">$ref = swe_rise_trans($tjd_ut, $ipl, $star, $epheflag, $rsmi, $geopos, $atpress, $attemp);</a></li>
      <li><a href="#ref-swe_rise_trans_true_hor-tjd_ut-ipl-star-epheflag-rsmi-geopos-atpress-attemp-horhgt">$ref = swe_rise_trans_true_hor($tjd_ut, $ipl, $star, $epheflag, $rsmi, $geopos, $atpress, $attemp, $horhgt);</a></li>
    </ul>
  </li>
  <li><a href="#Nodes-and-Apsides-orbital-elements">Nodes and Apsides, orbital elements</a>
    <ul>
      <li><a href="#ref-swe_nod_aps-tjd_et-ipl-iflag-method-head2-ref-swe_nod_aps_ut-tjd_ut-ipl-iflag-method">$ref = swe_nod_aps($tjd_et, $ipl, $iflag, $method); =head2 $ref = swe_nod_aps_ut($tjd_ut, $ipl, $iflag, $method);</a></li>
      <li><a href="#ref-swe_get_orbital_elements-tjd_et-ipl-iflag">$ref = swe_get_orbital_elements($tjd_et, $ipl, $iflag);</a></li>
      <li><a href="#ref-swe_orbit_max_min_true_distance-tjd_et-ipl-iflag">$ref = swe_orbit_max_min_true_distance($tjd_et, $ipl, $iflag);</a></li>
    </ul>
  </li>
  <li><a href="#Eclipses-and-Occultations-by-the-Moon">Eclipses and Occultations by the Moon</a>
    <ul>
      <li><a href="#ref-swe_sol_eclipse_when_glob-tjd_ut-iflag-ifltype-backw">$ref = swe_sol_eclipse_when_glob($tjd_ut, $iflag, $ifltype, $backw);</a></li>
      <li><a href="#ref-swe_sol_eclipse_when_loc-tjd_ut-iflag-backw-geopos">$ref = swe_sol_eclipse_when_loc($tjd_ut, $iflag, $backw, $geopos);</a></li>
      <li><a href="#ref-swe_sol_eclipse_where-tjd_ut-iflag">$ref = swe_sol_eclipse_where($tjd_ut, $iflag);</a></li>
      <li><a href="#ref-swe_sol_eclipse_how-tjd_ut-iflag-geopos">$ref = swe_sol_eclipse_how($tjd_ut, $iflag, $geopos);</a></li>
      <li><a href="#ref-swe_lun_eclipse_when-tjd_ut-iflag-ifltype-backw">$ref = swe_lun_eclipse_when($tjd_ut, $iflag, $ifltype, $backw);</a></li>
      <li><a href="#ref-swe_lun_eclipse_when_loc-tjd_ut-iflag-backw-geopos">$ref = swe_lun_eclipse_when_loc($tjd_ut, $iflag, $backw, $geopos);</a></li>
      <li><a href="#ref-swe_lun_eclipse_how-tjd_ut-iflag-geopos">$ref = swe_lun_eclipse_how($tjd_ut, $iflag, $geopos);</a></li>
      <li><a href="#ref-swe_lun_occult_when_glob-tjd_ut-ipl-star-iflag-ifltype-backw">$ref = swe_lun_occult_when_glob($tjd_ut, $ipl, $star, $iflag, $ifltype, $backw);</a></li>
      <li><a href="#ref-swe_lun_occult_when_loc-tjd_ut-ipl-star-iflag-backw-geopos">$ref = swe_lun_occult_when_loc($tjd_ut, $ipl, $star, $iflag, $backw, $geopos);</a></li>
      <li><a href="#ref-swe_lun_occult_where-tjd_ut-ipl-star-iflag">$ref = swe_lun_occult_where($tjd_ut, $ipl, $star, $iflag);</a></li>
    </ul>
  </li>
  <li><a href="#Coordinate-Transformations">Coordinate Transformations</a>
    <ul>
      <li><a href="#cout-swe_cotrans-cin-eps">@cout = swe_cotrans(\@cin, $eps);</a></li>
      <li><a href="#cout-swe_cotrans_sp-cin-eps">@cout = swe_cotrans_sp(\@cin, $eps);</a></li>
      <li><a href="#ref-swe_azalt-tjd_ut-calcflag-geopos-atpress-attemp-xin">$ref = swe_azalt($tjd_ut, $calcflag, $geopos, $atpress, $attemp, $xin);</a></li>
      <li><a href="#ref-swe_azalt_rev-tjd_ut-calcflag-geopos-atpress-attemp-xin">$ref = swe_azalt_rev($tjd_ut, $calcflag, $geopos, $atpress, $attemp, $xin);</a></li>
    </ul>
  </li>
  <li><a href="#Astrological-Houses">Astrological Houses</a>
    <ul>
      <li><a href="#ref-swe_houses-tjd_ut-geolat-geolon-hsys">$ref = swe_houses($tjd_ut, $geolat, $geolon, $hsys);</a></li>
      <li><a href="#ref-swe_houses_ex-tjd_ut-iflag-geolat-geolon-hsys">$ref = swe_houses_ex($tjd_ut, $iflag, $geolat, $geolon, $hsys);</a></li>
      <li><a href="#ref-swe_houses_ex2-tjd_ut-iflag-geolat-geolon-hsys">$ref = swe_houses_ex2($tjd_ut, $iflag, $geolat, $geolon, $hsys);</a></li>
      <li><a href="#ref-swe_houses_armc-tjd_ut-geolat-geolon-hsys">$ref = swe_houses_armc($tjd_ut, $geolat, $geolon, $hsys);</a></li>
      <li><a href="#ref-swe_houses_armc_ex2-tjd_ut-geolat-geolon-hsys">$ref = swe_houses_armc_ex2($tjd_ut, $geolat, $geolon, $hsys);</a></li>
      <li><a href="#ref-swe_house_pos-armc-geolat-eps-hsys-ecl_lon-ecl_lat">$ref = swe_house_pos($armc, $geolat, $eps, $hsys, $ecl_lon, $ecl_lat);</a></li>
      <li><a href="#hnam-swe_house_name-hsys">$hnam = swe_house_name($hsys);</a></li>
      <li><a href="#ref-swe_gauquelin_sector-tjd_ut-ipl-star-iflag-imeth-geopos-atpress-attemp">$ref = swe_gauquelin_sector($tjd_ut, $ipl, $star, $iflag, $imeth, $geopos, $atpress, $attemp);</a></li>
    </ul>
  </li>
  <li><a href="#Refraction">Refraction</a>
    <ul>
      <li><a href="#outalt-swe_refrac-inalt-atpress-attemp-calcflag">$outalt = swe_refrac($inalt, $atpress, $attemp, $calcflag);</a></li>
      <li><a href="#ref-swe_refrac_extended-inalt-geoalt-atpress-attemp-lapserate-calcflag">$ref = swe_refrac_extended($inalt, $geoalt, $atpress, $attemp, $lapserate, $calcflag);</a></li>
    </ul>
  </li>
  <li><a href="#Heliacal-Phenomena">Heliacal Phenomena</a>
    <ul>
      <li><a href="#ref-swe_heliacal_ut-tjd_start-dgeo-datm-dobs-objname-type_event-iflag">$ref = swe_heliacal_ut($tjd_start, $dgeo, $datm, $dobs, $objname, $type_event, $iflag)</a></li>
      <li><a href="#ref-swe_vis_limit_mag-tjd_start-dgeo-datm-dobs-objname-iflag">$ref = swe_vis_limit_mag($tjd_start, $dgeo, $datm, $dobs, $objname, $iflag)</a></li>
    </ul>
  </li>
  <li><a href="#Normalisation-to-360-and-Angles-between-Ecliptic-Points">Normalisation to 360&deg; and Angles between Ecliptic Points</a>
    <ul>
      <li><a href="#ddeg-swe_degnorm-ddeg">$ddeg = swe_degnorm($ddeg);</a></li>
      <li><a href="#drad-swe_radnorm-drad">$drad = swe_radnorm($drad);</a></li>
      <li><a href="#ddeg-swe_difdegn-ddeg1-ddeg2">$ddeg = swe_difdegn($ddeg1, $ddeg2);</a></li>
      <li><a href="#ddeg-swe_difdegn-ddeg1-ddeg21">$ddeg = swe_difdegn($ddeg1, $ddeg2);</a></li>
      <li><a href="#ddeg-swe_difdeg2n-ddeg1-ddeg2">$ddeg = swe_difdeg2n($ddeg1, $ddeg2);</a></li>
      <li><a href="#drad-swe_difrad2n-drad1-drad2">$drad = swe_difrad2n($drad1, $drad2);</a></li>
      <li><a href="#ddeg-swe_deg_midp-ddeg1-ddeg2">$ddeg = swe_deg_midp($ddeg1, $ddeg2);</a></li>
      <li><a href="#drad-swe_rad_midp-drad1-drad2">$drad = swe_rad_midp($drad1, $drad2);</a></li>
      <li><a href="#ref-swe_split_deg-ddeg-splitflag">$ref swe_split_deg($ddeg, $splitflag);</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a>
    <ul>
      <li><a href="#License-conditions">License conditions</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>SwissEph - The Swiss Ephemeris Perl Module</p>

<p>It is maintained on Github https://github.com/aloistr/perl-sweph</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<h2 id="DESCRIPTION">DESCRIPTION</h2>

<p>SwissEph is a Perl wrapper for the Swiss Ephemeris (see https://www.astro.com/swisseph). It is implemented as an XSUB.</p>

<p>This manual only tells how to call the Swiss Ephemeris functions from Perl. For more detailed information, use the Swiss Ephemeris Programmers&#39; Manual and the general documentation: https://www.astro.com/swisseph/swephprg.htm and https://www.astro.com/swisseph/swisseph.htm</p>

<p>For questions not answered in the documentation, please become a member of the Swiss Ephemeris Mailing list: swisseph@groups.io and ask them there.</p>

<p>For installation instructions, please see the README file on github https://github.com/aloistr/perl-sweph</p>

<h2 id="Simple-example">Simple example</h2>

<pre><code>  use SwissEph qw(:all);

  my $ERR = -1;
  my $day = 1;
  my $month = 1;
  my $year = 2000;
  my $hour = 2.9876;
  my $gregflag = SE_GREG_CAL; # for Gregorian calendar
  my $geolat = 47; # geographical latitude
  my $geolon =  8; # geographical longitude
  
  # Julian day number UT
  my $tjd_ut = swe_julday($year, $month, $day, $hour, $gregflag);

  # position of Sun
  my $ref = swe_calc_ut($tjd_ut, SE_SUN, SEFLG_SPEED);
  if ($ref-&gt;{retval} == $ERR) {
    print &quot;Error: $ref-&gt;{serr}\n&quot;;
    exit;
  }
  print &quot;Position of Sun:\n&quot;;
  print &quot;long=$ref-&gt;{xx}-&gt;[0], lat=$ref-&gt;{xx}-&gt;[1], r=$ref-&gt;{xx}-&gt;[2], &quot;;
  print &quot;speed=$ref-&gt;{xx}-&gt;[3]\n&quot;;

  # House cusps, Placidus
  $ref = swe_houses($tjd_ut, $geolat, $geolon, &quot;P&quot;);
  print &quot;armc = $ref-&gt;{armc}\n&quot;;
  print &quot;mc   = $ref-&gt;{mc}\n&quot;;
  print &quot;asc  = $ref-&gt;{asc}\n&quot;;
  print &quot;houses:\n&quot;;
  for (my $i = 1; $i &lt;= 12; $i++) {
    print &quot;  $i:\t$ref-&gt;{cusps}-&gt;[$i]\n&quot;;
  }</code></pre>

<h2 id="Testing-functions-from-command-line">Testing functions from command line</h2>

<p>perl -e allows testing of functions directly from the command line. Example</p>

<p>perl -e &#39;use SwissEph qw(:all); use Data::Dumper qw( Dumper ); $r = swe_calc(2340000,SE_PLUTO,SEFLG_SPEED); print Dumper($r);&#39;</p>

<pre><code>  $VAR1 = {
          &#39;retval&#39; =&gt; 256,
          &#39;xx&#39; =&gt; [
                    &#39;122.130807298779&#39;,
                    &#39;4.62520037690129&#39;,
                    &#39;39.2320159608655&#39;,
                    &#39;0.0280505903662191&#39;,
                    &#39;0.00160563980064327&#39;,
                    &#39;-0.00462759291078111&#39;
                  ]
        };</code></pre>

<h2 id="EXPORT">EXPORT</h2>

<p>None by default. Any function can be imported (all functions are included in <code>@EXPORT_OK</code>). All functions can be imported as follows:</p>

<p>use SwissEph(&#39;:all&#39;);</p>

<p>In addition to the functions declared in the XS file, the module SwissEph.pm exports all constants required for the use of the Swiss Ephemeris.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="ref-swe_version">$ref = swe_version();</h2>

<h3 id="Output:-ref-hash-reference-which-contains">Output: $ref hash reference, which contains:</h3>

<pre><code>  -&gt;version_sweperl  Version number of Perl wrapper (from SwissEph.pm)
  -&gt;version_swisseph Version of Swiss Ephemeris (from SE_VERSION)</code></pre>

<h2 id="lpath-swe_get_library_path">$lpath = swe_get_library_path();</h2>

<p>Function returns path in which the dynamical Swiss Ephemeris library libswe.so resides. If it is running with a DLL, then it returns the path of the DLL. If SwissEph.so is linked statically with libswe.a, the path of SwissEph.so is returned.</p>

<h1 id="Opening-and-Closing-the-Ephemeris">Opening and Closing the Ephemeris</h1>

<h2 id="swe_set_ephe_path-path">swe_set_ephe_path($path);</h2>

<pre><code>  Function tells the SwissEphemeris where to finde the ephemeris files.</code></pre>

<h3 id="Input:-path-Path-of-the-ephemeris-files">Input: $path Path of the ephemeris files</h3>

<h2 id="swe_set_jpl_file-filename">swe_set_jpl_file($filename);</h2>

<p>Function tells the SwissEphemeris which JPL ephemeris file to use.</p>

<p>This function is only needed if a JPL ephemeris is used, and if this JPL ephemeris is not the standard one.</p>

<h2 id="swe_close">swe_close( );</h2>

<p>Function closes all open files and frees all space that was allocated for the use of the Swiss Ephemeris.</p>

<h1 id="Julian-Day-Number-and-Calendar-Conversions">Julian Day Number and Calendar Conversions</h1>

<h2 id="tjd-swe_julday-year-month-day-hour-calflag">$tjd = swe_julday($year, $month, $day, $hour, $calflag);</h2>

<p>Function calculates the Julian Daynumber from a calendar date. $calflag can have two values:</p>

<pre><code>  $calflag=SE_GREG_CAL; # use Gregorian calendar
  $calflag=SE_JUL_CAL;  # use Gregorian calendar</code></pre>

<p>$calflag may be omitted. If so, calendar dates before 1582/10/15 are treated as Julian, whereas dates after 1582/10/15 are treated as Gregorian.</p>

<p>The function does no range check on input values. For example, month = 4, day = 31 will be interpreted like monht = 5, day = 1.</p>

<h2 id="ref-swe_revjul-tjd-calflag">$ref = swe_revjul($tjd, $calflag);</h2>

<p>Function calculates the calendar date of a given julian day number. $calflag is optional, vide explanation of swe_julday( ).</p>

<h3 id="Output:-ref-hash-reference-which-contains1">Output: $ref hash reference, which contains:</h3>

<pre><code>      -&gt;iyar   year
      -&gt;imon   month
      -&gt;iday   day
      -&gt;dhou   hour (double)
      -&gt;ihour  hour (integer)
      -&gt;imin   minute
      -&gt;dsec   second (double)</code></pre>

<h2 id="ref-swe_utc_time_zone-year-month-day-hour-min-sec-dtimezone">$ref = swe_utc_time_zone($year, $month, $day, $hour, $min, $sec, $dtimezone);</h2>

<p>Function converts local time to UTC, given a time zone offset, or UTC to local time, in hours.</p>

<h3 id="input">input</h3>

<pre><code>    year ... sec     date and time (sec may be a double)
    dtimezone       timezone offset, in hours</code></pre>

<h3 id="Output:-ref-hash-reference-which-contains2">Output: $ref hash reference, which contains:</h3>

<pre><code>      -&gt;iyear_out   year
      -&gt;imonth_out  month
      -&gt;iday_out    day
      -&gt;ihour_out   hour (integer)
      -&gt;imin_out    minute
      -&gt;dsec_out    second (double)
 
  For time zones east of Greenwich, d_timezone is positive.
  For time zones west of Greenwich, d_timezone is negative.
 
  For conversion from local time to utc, use +d_timezone.
  For conversion from utc to local time, use -d_timezone.</code></pre>

<h2 id="ref-swe_utc_to_jd-iyar-imon-iday-ihou-imin-dsec-calflag">$ref = swe_utc_to_jd($iyar, $imon, $iday, $ihou, $imin, $dsec, $calflag);</h2>

<p>Function calculates the Julian Daynumber from a calendar date in UTC. As for the input, note that dsec is a double. $calflag is optional, see explanation of swe_julday( ). Note: 60 &lt;= dsec &lt; 61 is allowed, if it is a valid leap second.</p>

<h3 id="Output:-ref-hash-reference-which-contains3">Output: $ref hash reference, which contains:</h3>

<pre><code>      -&gt;retval ERR or OK
      -&gt;serr   Error string, on error only
      -&gt;tjd_ut Julian day UT (UT1)
      -&gt;tjd_et Julian day ET (TT)</code></pre>

<h2 id="ref-swe_jdet_to_utc-tjd-calflag">$ref = swe_jdet_to_utc($tjd, $calflag);</h2>

<p>Function calculates the calendar date UTC for a given Julian day number, where the Julian day number is ET (TT). $calflag is optional, see explanation of swe_julday( ).</p>

<h3 id="Output:-ref-hash-reference-which-contains4">Output: $ref hash reference, which contains:</h3>

<pre><code>      -&gt;iyar   year
      -&gt;imon   month
      -&gt;iday   day
      -&gt;ihour  hour 
      -&gt;imin   minute
      -&gt;dsec   second
  Note: in case of a leap second, 60 &lt;= dsec &lt; 61</code></pre>

<h2 id="ref-swe_jdut1_to_utc-tjd-calflag">$ref = swe_jdut1_to_utc($tjd, $calflag);</h2>

<p>Function calculates the calendar date UTC for a given Julian day number, where the Julian day number is UT (UT1). $calflag is optional, see explanation of swe_julday( ).</p>

<h3 id="Output:-ref-hash-reference-which-contains5">Output: $ref hash reference, which contains:</h3>

<pre><code>      -&gt;iyar   year
      -&gt;imon   month
      -&gt;iday   day
      -&gt;ihour  hour 
      -&gt;imin   minute
      -&gt;dsec   second
  Note: in case of a leap second, 60 &lt;= dsec &lt; 61</code></pre>

<h2 id="dow-swe_day_of_week-tjd">$dow = swe_day_of_week($tjd);</h2>

<p>Function returns the day of week for a Julian day number. Monday = 0, ... Sunday = 6.</p>

<h1 id="Delta-T-and-Tidal-Acceleration-of-the-Moon">Delta T and Tidal Acceleration of the Moon</h1>

<h2 id="dt-swe_deltat-tjd_ut">$dt = swe_deltat($tjd_ut);</h2>

<p>Function calculates Delta T for a given Julian day number in Ephemeris Time.</p>

<h3 id="Input:-tjd_ut-Julian-day-number-Universal-Time">Input: $tjd_ut Julian day number, Universal Time</h3>

<h3 id="Output:-dt-Delta-T-in-days">Output: $dt Delta T in days</h3>

<p>Unless you use the Moshier ephemeris, do not use this function before calling swe_set_ephe_path() or swe_set_jplfile().</p>

<h2 id="ref-swe_deltat_ex-tjd_ut-ephe_flag">$ref = swe_deltat_ex($tjd_ut, $ephe_flag);</h2>

<p>Function calculates Delta T for a given Julian day number in Ephemeris Time. Delta T value is adjusted to ephemeris chosen.</p>

<h3 id="Input">Input:</h3>

<pre><code>  $tjd_ut   Julian day number, Universal Time
  $epheflag Ephemeris flag SEFLG_SWIEPH, SEFLG_JPLEPH, or SEFLG_MOSEPH</code></pre>

<h3 id="Output">Output:</h3>

<pre><code>  $dt       Delta T in days
  $serr     warning (optional)

  Unless you use the Moshier ephemeris, do not use this
  function before calling swe_set_ephe_path() or swe_set_jplfile().</code></pre>

<h2 id="swe_set_delta_t_userdef-dt">swe_set_delta_t_userdef($dt);</h2>

<p>Function sets Delta T to a fixed user-defined value. After a call of this function, swe_deltat() and swe_deltat_ex() always return the value set by this function. In order to return to automatic Delta T, call swe_set_delta_t_userdef(SE_DELTAT_AUTOMATIC).</p>

<h2 id="tacc-swe_get_tid_acc">$tacc = swe_get_tid_acc( );</h2>

<p>Function returns the tidal acceleration on which the Swiss Ephemeris is based.</p>

<h2 id="swe_set_tid_acc-tacc">swe_set_tid_acc($tacc);</h2>

<p>Function sets the tidal acceleration to any other value. This is relevant for Delta T calculations.</p>

<h1 id="Sidereal-Time">Sidereal Time</h1>

<h2 id="tsid-swe_sidtime-tjd_ut">$tsid = swe_sidtime($tjd_ut);</h2>

<p>Function calculates sidereal time in hours for a given Julian day number in Universal Time.</p>

<h2 id="tsid-swe_sidtime0-tjd_ut-eps-nut">$tsid = swe_sidtime0($tjd_ut, $eps, $nut);</h2>

<p>Function calculates sidereal time in hours</p>

<h3 id="Input1">Input:</h3>

<p>$tjd_ut Julian day number in Universal Time $eps Obliquity of ecliptic, degrees $nut Nutation in longitude, degrees</p>

<p>This function provides the same result as swe_sidtime(), if $eps is the obliquity of the true ecliptic of date (mean eps + nutation in obliquity).</p>

<h1 id="Time-Equation">Time Equation</h1>

<h2 id="ref-swe_time_equ-tjd_ut">$ref = swe_time_equ($tjd_ut);</h2>

<p>Function calculates the time equation</p>

<h3 id="Input:-tjd_ut-Julian-day-number-Universal-Time1">Input: $tjd_ut Julian day number, Universal Time</h3>

<h3 id="Output:-ref-hash-reference-which-contains6">Output: $ref hash reference, which contains:</h3>

<pre><code>        -&gt; retval     OK or ERR
        -&gt; time_equ   time equation in days
        -&gt; serr       error message (on error only)</code></pre>

<h2 id="Conversions-between-LMT-and-LAT-Local-Mean-Apparent-Time">Conversions between LMT and LAT (Local Mean/Apparent Time)</h2>

<h2 id="ref-swe_lmt_to_lat-tjd_lmt-geolon">$ref = swe_lmt_to_lat($tjd_lmt, $geolon);</h2>

<p>Function converts Local Mean Time to Local Apparent Time</p>

<h3 id="Input2">Input:</h3>

<pre><code>        $tjd_lmt Julian day number, Local Mean Time
        $geolon  geographic longitude</code></pre>

<h3 id="Output:-ref-hash-reference-which-contains7">Output: $ref hash reference, which contains:</h3>

<pre><code>          -&gt; retval     OK or ERR
          -&gt; tjd_lat   Julian day number, Local Apparent time
          -&gt; serr       error message (on error only)</code></pre>

<h2 id="ref-swe_lat_to_lmt-tjd_lat-geolon">$ref = swe_lat_to_lmt($tjd_lat, $geolon);</h2>

<p>Function converts Local Apparent Time to Local Mean Time</p>

<h3 id="Input3">Input:</h3>

<pre><code>        $tjd_lat Julian day number, Local Apparent Time
        $geolon  geographic longitude</code></pre>

<h3 id="Output:-ref-hash-reference-which-contains8">Output: $ref hash reference, which contains:</h3>

<pre><code>        -&gt; retval     OK or ERR
        -&gt; tjd_lmt   Julian day number, Local Mean time
        -&gt; serr       error message (on error only)</code></pre>

<h1 id="Positions-of-Celestial-Bodies">Positions of Celestial Bodies</h1>

<h2 id="ref-swe_calc-tjd_et-ipl-iflag">$ref = swe_calc($tjd_et, $ipl, $iflag);</h2>

<p>Function calculates the position of a planet or asteroid.</p>

<h3 id="Input4">Input:</h3>

<pre><code>        $tjd_et  Julian day number, Ephemeris Time
        $ipl     Planet identification number (see below)
        $iflag   Calculation specifications (see below)</code></pre>

<h3 id="Output:-ref-hash-reference-which-contains9">Output: $ref hash reference, which contains:</h3>

<pre><code>        -&gt; retval     ERR or $iflag; $iflag may have been corrected
        -&gt; serr  Error string, on error only
        -&gt; xx    array reference for array of 6 doubles.
          The content of this array depends on the calculation specifications in iflag.</code></pre>

<h2 id="ref-swe_calc_ut-tjd_ut-ipl-iflag">$ref = swe_calc_ut($tjd_ut, $ipl, $iflag);</h2>

<p>Function does the same as swe_calc(), but for a Universal Time Julian day number.</p>

<h3 id="Input5">Input:</h3>

<pre><code>        $tjd_ut  Julian day number, Universal Time
        $ipl     Planet identification number (see below)
        $iflag   Calculation specifications (see below)</code></pre>

<h3 id="Output:-ref-hash-reference-which-contains10">Output: $ref hash reference, which contains:</h3>

<pre><code>        -&gt; retval     ERR or $iflag; $iflag may have been corrected
        -&gt; serr  Error string, on error only
        -&gt; xx    array reference for array of 6 doubles.
          The content of this array depends on the calculation specifications in iflag.</code></pre>

<h2 id="ref-swe_calc_pctr-tjd_et-ipl-iplctr-iflag">$ref = swe_calc_pctr($tjd_et, $ipl, $iplctr, $iflag);</h2>

<p>Function calculates the position of a planet or asteroid, relative to a center object iplctr</p>

<h3 id="Input6">Input:</h3>

<pre><code>        $tjd_et  Julian day number, Ephemeris Time
        $ipl     Planet identification number (see below)
        $iplctr  center planet number
        $iflag   Calculation specifications (see below)</code></pre>

<h3 id="Output:-ref-hash-reference-which-contains11">Output: $ref hash reference, which contains:</h3>

<pre><code>        -&gt; retval     ERR or $iflag; $iflag may have been corrected
        -&gt; serr  Error string, on error only
        -&gt; xx    array reference for array of 6 doubles.
          The content of this array depends on the calculation specifications in iflag.</code></pre>

<h2 id="Planet-numbers-ipl-for-swe_calc-function-family">Planet numbers ($ipl) for swe_calc() function family</h2>

<pre><code>  Many Swiss Ephemeris functions use planet numbers to identify the
  planet for which a calculation is to be done. For this, you can
  use the constants defined in SwissEph.pm:

  SE_SUN, SE_MOON, SE_MERCURY, SE_VENUS, SE_MARS, SE_JUPITER, 
  SE_SATURN, SE_URANUS, SE_NEPTUNE, SE_PLUTO, SE_MEAN_NODE, 
  SE_TRUE_NODE, SE_MEAN_APOG, SE_OSCU_APOG, SE_INTP_APOG,
  SE_INTP_PERG, SE_EARTH, SE_CHIRON, SE_PHOLUS, SE_CERES, 
  SE_PALLAS, SE_JUNO, SE_VESTA.

  For asteroids, the planet number is defined as:
  $ipl = SE_AST_OFFSET + minor_planet_catalogue_number;

  For more info, e.g. fictitious bodies, see the constants list
  in SwissEph.pm.</code></pre>

<h2 id="Calculation-flags-iflag-for-swe_calc">Calculation flags ($iflag) for swe_calc( )</h2>

<pre><code>  The function swe_calc( ) can provide different kinds of planetary 
  positions, e.g. it can provide them in different coordinate systems,
  or it can provid true or apparent positions, geocentric, heliocentric,
  or barycentric positions, etc. etc. In order to specify the result 
  you need, use the input variable $iflag. $iflag is a bit map. The
  calculation specification are or&#39;ed as single bits to this bit map.

  SEFLG_JPLEPH = 1          # use JPL ephemeris
  SEFLG_SWIEPH = 2          # use SWISSEPH ephemeris
  SEFLG_MOSEPH = 4          # use Moshier ephemeris
  SEFLG_DEFAULTEPH = SEFLG_SWIEPH  
  SEFLG_HELCTR = 8          # return heliocentric position
  SEFLG_TRUEPOS = 16        # return true positions, not apparent
  SEFLG_J2000 = 32          # no precession, i.e. give J2000 equinox
  SEFLG_NONUT = 64          # no nutation, i.e. mean equinox of date
  SEFLG_SPEED3 = 128        # speed from 3 positions (do not use it,
                            # SEFLG_SPEED is faster and more precise.)
  SEFLG_SPEED = 256         # high precision speed
  SEFLG_NOGDEFL = 512       # turn off gravitational deflection
  SEFLG_NOABERR = 1024      # turn off &#39;annual&#39; aberration of light
  SEFLG_EQUATORIAL = (2*1024) # equatorial positions are wanted
  SEFLG_XYZ = (4*1024)      # cartesian, not polar, coordinates
  SEFLG_RADIANS = (8*1024)  # coordinates in radians, not degrees
  SEFLG_BARYCTR = (16*1024) # barycentric positions
  SEFLG_TOPOCTR = (32*1024) # topocentric positions
  SEFLG_SIDEREAL = (64*1024)# sidereal positions
  SEFLG_ICRS = (128*1024)   # ICRS (DE406 reference frame)
  SEFLG_DPSIDEPS_1980 = (256*1024) # reproduce JPL Horizons
                                   # 1962 - today to 0.002 arcsec.
  SEFLG_JPLHOR = (256*1024)        # same
  SEFLG_JPLHOR_APPROX = (512*1024) # approximate JPL Horizons 1962 - today
  SEFLG_CENTER_BODY   = (1024*1024)# calculate position of center of body (COB) of planet, not barycenter of its system </code></pre>

<h2 id="swe_set_topo-geolon-geolat-geoalt">swe_set_topo($geolon, $geolat, $geoalt);</h2>

<pre><code>  Function sets the geographical position for topocentric calculations.
  Call this function before calling swe_calc( ) with the topocentric 
  flag (SEFLG_TOPOCTR).

  Input:  $geolon  Geographical longitude
          $geolat  Geographical latitude
          $geoalt  Height above sea level in meters</code></pre>

<h2 id="swe_set_ayanamsa-isidmode-t0-ayan_t0">swe_set_ayanamsa($isidmode, t0, ayan_t0);</h2>

<pre><code>  Function sets the ayanamsa for the calculation of sidereal positions
  of planets or fixed stars. Call this function before calling swe_calc( )
  with the sidereal flag (SEFLG_SIDEREAL).

  Input:  $isidmode Sidereal mode, s. below.
          $t0       To define your own ayanamsa: start time.
                    0, if you use a predefined ayanamsa
          $ayan_t0  To define your own ayanamsa: ayanamsa at start time
                    0, if you use a predefined ayanamsa

  Predefined ayanamsas:
  SE_SIDM_FAGAN_BRADLEY, SE_SIDM_LAHIRI. For the other predefined 
  ayanamsas, please study the C Programmer&#39;s Manual.</code></pre>

<h2 id="daya-swe_get_ayanamsa-tjd_et">$daya = swe_get_ayanamsa($tjd_et);</h2>

<pre><code>  Function returns the ayanamsa for a Julian day number.

  Input:  $tjd_et  Julian day number in Ephemeris Time

  Output: $daya    Ayanamsa in degrees</code></pre>

<h2 id="daya-swe_get_ayanamsa_ut-tjd_ut">$daya = swe_get_ayanamsa_ut($tjd_ut);</h2>

<pre><code>  Function does the same as swe_get_ayanamsa( ), but input parameter
  $tjd_ut is Universal Time.</code></pre>

<h2 id="ref-swe_get_ayanamsa_ex-tjd_et-epheflag">$ref = swe_get_ayanamsa_ex($tjd_et, epheflag);</h2>

<pre><code>  Function returns the ayanamsa for a Julian day number, depending on
  ephemeris chosen.

  Input:  $tjd_et  Julian day number in Ephemeris Time

  Output: $ref     hash reference, which contains:

          -&gt;retval  return value, either ERR or ephemeris flag
          -&gt;daya    Ayanamsa in degrees
          -&gt;serr    error message, on error only</code></pre>

<h2 id="ref-swe_get_ayanamsa_ex_ut-tjd_ut-epheflag">$ref = swe_get_ayanamsa_ex_ut($tjd_ut, epheflag);</h2>

<pre><code>  Function does the same as swe_get_ayanamsa_ex(), but input parameter
  $tjd_ut is Universal Time.</code></pre>

<h2 id="ayanam-swe_get_ayanamsa_name-isidmode">$ayanam = swe_get_ayanamsa_name($isidmode);</h2>

<pre><code>  Function returns the name of the ayanamsa.</code></pre>

<h1 id="Positions-of-Fixed-Stars">Positions of Fixed Stars</h1>

<h2 id="ref-swe_fixstar-star-tjd_et-iflag">$ref = swe_fixstar($star, $tjd_et, $iflag);</h2>

<h2 id="ref-swe_fixstar2-star-tjd_et-iflag">$ref = swe_fixstar2($star, $tjd_et, $iflag);</h2>

<pre><code>  Function calculates the position of a fixed star.

  Input:  $star    Star name, e.g. &quot;spica&quot; or &quot;alVir&quot;
          $tjd_et  Julian day number, Ephemeris Time
          $iflag   Calculation specifications (see above)

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or $iflag; $iflag may have been corrected
          -&gt; serr  Error string, on error only
          -&gt; xx    hash reference. The content of this
                   array depends on the calculation specifications
                   in iflag.
          -&gt; starname Corrected star name, e.g. like &quot;Spica,alVir&quot;

  Function swe_fixstar2() has better performance with great numbers
  of fixed star calculations.</code></pre>

<h2 id="ref-swe_fixstar_ut-star-tjd_ut-iflag">$ref = swe_fixstar_ut($star, $tjd_ut, $iflag);</h2>

<h2 id="ref-swe_fixstar2_ut-star-tjd_ut-iflag">$ref = swe_fixstar2_ut($star, $tjd_ut, $iflag);</h2>

<pre><code>  Function does the same as swe_fixstar( ), but for a Universal Time
  Julian day number.

  Function swe_fixstar2_ut() has better performance with great numbers
  of fixed star calculations.</code></pre>

<h1 id="Name-Magnitude-Phase-Elongation-Disc-Diameter-etc">Name, Magnitude, Phase, Elongation, Disc Diameter, etc.</h1>

<h2 id="name-swe_get_planet_name-ipl">$name = swe_get_planet_name($ipl);</h2>

<pre><code>  Function returns the planet name.

  Input:  $ipl     Planet identification number

  Output: $name    Name of planet.</code></pre>

<h2 id="ref-swe_pheno-tjd_et-ipl-iflag">$ref = swe_pheno($tjd_et, $ipl, $iflag);</h2>

<pre><code>  Function calculates the position of a planet or asteroid.

  Input:  $tjd_et  Julian day number, Ephemeris Time
          $ipl     Planet identification number
          $iflag   Calculation specifications

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or $iflag; $iflag may have been corrected
          -&gt; serr  Error string, on error only
          -&gt; attr  Array reference. Array contains the values 
                   of the following hash members.
          -&gt; phase_angle Phase angle (Earth-Planet-Sun)
          -&gt; phase Phase (illumined fraction of disc)
          -&gt; elongation 
          -&gt; disc_diameter
          -&gt; magnitude
          -&gt; hor_parallax   Horizontal parallax of the Moon.</code></pre>

<h2 id="ref-swe_pheno-tjd_et-ipl-iflag1">$ref = swe_pheno($tjd_et, $ipl, $iflag);</h2>

<pre><code>  Function does the same as swe_pheno( ), but for a Universal Time
  Julian day number.</code></pre>

<h2 id="ref-swe_fixstar_mag-star-head2-ref-swe_fixstar2_mag-star">$ref = swe_fixstar_mag($star); =head2 $ref = swe_fixstar2_mag($star);</h2>

<pre><code>  Function calculates the magnitude of a fixed star.

  Input:  $star    Star name, e.g. &quot;spica&quot; or &quot;alVir&quot;

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or OK
          -&gt; serr  Error string, on error only
          -&gt; dmag  Magnitude of fixed star
          -&gt; starname Corrected star name, e.g. like &quot;Spica,alVir&quot;

  Function swe_fixstar2_mag() has better performance with great numbers
  of fixed star calculations.</code></pre>

<h1 id="Rising-Setting-and-Meridian-Transits">Rising, Setting and Meridian Transits</h1>

<h2 id="ref-swe_rise_trans-tjd_ut-ipl-star-epheflag-rsmi-geopos-atpress-attemp">$ref = swe_rise_trans($tjd_ut, $ipl, $star, $epheflag, $rsmi, $geopos, $atpress, $attemp);</h2>

<pre><code>  Function calculates the rising, setting, or meridian transit of 
  a celestial body.

  Input:  $tjd_ut  Julian day number, Universal Time
          $ipl     Planet identification number
          $star    Star name, if a star is calculated; otherwise &quot;&quot;
          $epheflag   Ephemeris flag, SEFLG_SWIEPH, SEFLG_JPLEPH, or
                   SEFLG_MOSEPH
          $rsmi    Calculation flag:
                   SE_CALC_RISE, SE_CALC_SET, SE_CALC_MTRANSIT,
                   SE_CALC_ITRANSIT.
                   | SE_BIT_DISC_CENTER   to calculate risings and settings
                                          for the disc center of the body
                   | SE_BIT_DISC_BOTTOM   to calculate risings and settings
                                          of lower limb of disc
                   | SE_BIT_NO_REFRACTION to neglect refraction
                   | SE_BIT_FIXED_DISC_SIZE (instead of apparent disc size)
                   | SE_BIT_CIVIL_TWILIGHT  for begin/end of twilight
                                            with $ipl = SE_SUN
                   | SE_BIT_NAUTIC_TWILIGHT dito
                   | SE_BIT_ASTRO_TWILIGHT  dito
                   | SE_BIT_HINDU_RISING    Hindu method for rising/setting
          $geopos  Pointer ot array of geogr. long., lat., height
          $atpress Atmospheric pressure in hPa (mbar)
          $attemp  Atmospheric temperature in degree C

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or OK
          -&gt; serr  Error string, on error only
          -&gt; dret  Julian day number in Universal Time of rising, etc.
          -&gt; starname  Corrected star name</code></pre>

<h2 id="ref-swe_rise_trans_true_hor-tjd_ut-ipl-star-epheflag-rsmi-geopos-atpress-attemp-horhgt">$ref = swe_rise_trans_true_hor($tjd_ut, $ipl, $star, $epheflag, $rsmi, $geopos, $atpress, $attemp, $horhgt);</h2>

<pre><code>  This function is similar to the function swe_rise_trans(), but
  the rising and setting can be calculated for a horizon which is 
  not flat. For this reason it has an additional parameter 
          $horhgt  height of the horizon in degrees at the point
                   where the body is expected to rise</code></pre>

<h1 id="Nodes-and-Apsides-orbital-elements">Nodes and Apsides, orbital elements</h1>

<h2 id="ref-swe_nod_aps-tjd_et-ipl-iflag-method-head2-ref-swe_nod_aps_ut-tjd_ut-ipl-iflag-method">$ref = swe_nod_aps($tjd_et, $ipl, $iflag, $method); =head2 $ref = swe_nod_aps_ut($tjd_ut, $ipl, $iflag, $method);</h2>

<pre><code>  Function calculates the positions of the nodes and apsides of 
  planets.

  Input:  $tjd_et  Julian day number, Ephemeris Time
          ($tjd_ut  Julian day number, Universal Time)
          $ipl     Planet identification number
          $iflag   (same parameter as with swe_calc( ))
          $method  (see C Programmer&#39;s Manual)=

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or $iflag; $iflag may have been corrected
          -&gt; serr  Error string, on error only
          -&gt; xnasc Array reference for position array of ascending node
          -&gt; xndsc Array reference for position array of descending node
          -&gt; xperi Array reference for position array of perihelion
          -&gt; xaphe Array reference for position array of aphelion</code></pre>

<h2 id="ref-swe_get_orbital_elements-tjd_et-ipl-iflag">$ref = swe_get_orbital_elements($tjd_et, $ipl, $iflag);</h2>

<pre><code>  Function calculates osculating Kepler elements relative to the
  mean equinox J2000 and other orbital data.

  Input:  $tjd_et  Julian day number, Ephemeris Time
          $ipl     Planet identification number
          $iflag   (same parameter as with swe_calc( ), although
                   some values do not make sense)

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or $iflag; $iflag may have been corrected
          -&gt; serr  Error string, on error only
          -&gt; dret  Array reference for data array. The same data are also
                   provided as follows (same order):
          -&gt; sema  semiaxis
          -&gt; ecce  eccentricity
          -&gt; incl  inclination
          -&gt; node  longitude of ascending node
          -&gt; parg  argument of perihelion
          -&gt; peri  longitude of perihelion
          -&gt; mean_anom    mean anomaly
          -&gt; true_anom    mean anomaly
          -&gt; ecce_anom    eccentric anomaly
          -&gt; sid_period   sidereal period in tropical years
          -&gt; daily_motion mean daily motion
          -&gt; trop_period  tropical period
          -&gt; synod_period synodic period
          -&gt; perihelion_time time of perihelion passage 
          -&gt; perihelion_distance 
          -&gt; aphelion_distance</code></pre>

<h2 id="ref-swe_orbit_max_min_true_distance-tjd_et-ipl-iflag">$ref = swe_orbit_max_min_true_distance($tjd_et, $ipl, $iflag);</h2>

<pre><code>  Function calculates the maximum, minimum and true distance
  of a planet from the EMB or the Sun, based on the osculating
  ellipses of the moment.

  Input:  $tjd_et  Julian day number, Ephemeris Time
          $ipl     Planet identification number
          $iflag   (same parameter as with swe_calc( ), although
                   some values do not make sense)

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or $iflag; $iflag may have been corrected
          -&gt; serr  Error string, on error only
          -&gt; dmax  maximum distance
          -&gt; dmin  minimum distance
          -&gt; dtrue true distance at $tjd_et</code></pre>

<h1 id="Eclipses-and-Occultations-by-the-Moon">Eclipses and Occultations by the Moon</h1>

<h2 id="ref-swe_sol_eclipse_when_glob-tjd_ut-iflag-ifltype-backw">$ref = swe_sol_eclipse_when_glob($tjd_ut, $iflag, $ifltype, $backw);</h2>

<pre><code>  Finds the next solar eclipse no matter where on earth.

  Input:  $tjd_ut  Julian day number, Universal Time
          $iflag   (specify ephemeris to be used, cf. swe_calc( ))
          $ifltype Eclipse type to be searched; 0 if any type of
                   eclipse is wanted
          $backw   Search backward in time

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or eclipse type
          -&gt; serr  Error string, on error only
          -&gt; tret  Array reference for array, which contains the values fo the
                   following hash members:
          -&gt; ecl_maximum      time of maximum eclipse (UT)
          -&gt; ecl_local_noon   time when eclipse happens at local noon (UT)
          -&gt; ecl_begin
          -&gt; ecl_end
          -&gt; ecl_total_begin
          -&gt; ecl_total_end
          -&gt; ecl_central_begin
          -&gt; ecl_central_end

  The following bits define the eclipse type
  SE_ECL_CENTRAL, SE_ECL_NONCENTRAL, SE_ECL_TOTAL, SE_ECL_ANNULAR,
  SE_ECL_PARTIAL, SE_ECL_ANNULAR_TOTAL</code></pre>

<h2 id="ref-swe_sol_eclipse_when_loc-tjd_ut-iflag-backw-geopos">$ref = swe_sol_eclipse_when_loc($tjd_ut, $iflag, $backw, $geopos);</h2>

<p>Finds the next solar eclipse for a given place on earth.</p>

<pre><code>  Input:  $tjd_ut  Julian day number, Universal Time
          $iflag   (specify ephemeris to be used, cf. swe_calc( ))
          $backw   Search backward in time
          $geopos  Array reference for array of geograph. long., lat., height

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or eclipse type
          -&gt; serr  Error string, on error only
          -&gt; tret  Array reference for array (s. C Programmer&#39;s Manual)
          -&gt; attr  Array reference for array (s. C Programmer&#39;s Manual)
          -&gt; ecl_maximum       time of maximum eclipse (UT)
          -&gt; t1st_contact
          -&gt; t2nd_contact
          -&gt; t3rd_contact
          -&gt; t4th_contact
          -&gt; disc_ratio        size ratio of the two discs
          -&gt; fraction_diameter percentage of diameter occulted
          -&gt; fraction_disc     percentage of disc occulted
          -&gt; core_shadow_km    diameter of core shadow (km, negative
                               with total, positive with annular ecl.)
          -&gt; sun_azimuth
          -&gt; sun_alt_true
          -&gt; sun_alt_app
          -&gt; separation_angle</code></pre>

<h2 id="ref-swe_sol_eclipse_where-tjd_ut-iflag">$ref = swe_sol_eclipse_where($tjd_ut, $iflag);</h2>

<p>Finds the place on earth where the eclipse is maximal at a given time.</p>

<pre><code>  Input:  $tjd_ut  Julian day number, Universal Time
          $iflag   (specify ephemeris to be used, cf. swe_calc( ))

  Output: $ref     hash reference, which contains:

          -&gt; retval            ERR or eclipse type
          -&gt; serr              Error string, on error only
          -&gt; attr              Array reference for array (s. Programmer&#39;s Manual)
          -&gt; geopos            Array reference for array, geogr. position
                               where eclipse is maximal
          -&gt; disc_ratio        size ratio of the two discs
          -&gt; fraction_diameter percentage of diameter occulted
          -&gt; fraction_disc     percentage of disc occulted
          -&gt; core_shadow_km    diameter of core shadow (km, negative
                               with total, positive with annular ecl.)
          -&gt; sun_azimuth
          -&gt; sun_alt_true
          -&gt; separation_angle
          -&gt; geo_long          (from geopos)
          -&gt; geo_lat           (from geopos)</code></pre>

<h2 id="ref-swe_sol_eclipse_how-tjd_ut-iflag-geopos">$ref = swe_sol_eclipse_how($tjd_ut, $iflag, $geopos);</h2>

<p>Function calculates local character of an eclipse</p>

<pre><code>  Input:  $tjd_ut  Julian day number, Universal Time
          $iflag   (specify ephemeris to be used, cf. swe_calc( ))
          $geopos  Array reference for array of geograph. long., lat., height

  Output: $ref     hash reference, which contains:

          -&gt; retval            ERR or eclipse type
          -&gt; serr              Error string, on error only
          -&gt; attr              Array reference for array (s. Programmer&#39;s Manual)
          -&gt; disc_ratio        size ratio of the two discs
          -&gt; fraction_diameter percentage of diameter occulted
          -&gt; fraction_disc     percentage of disc occulted
          -&gt; core_shadow_km    diameter of core shadow (km, negative
                               with total, positive with annular ecl.)
          -&gt; sun_azimuth
          -&gt; sun_alt_true
          -&gt; separation_angle</code></pre>

<h2 id="ref-swe_lun_eclipse_when-tjd_ut-iflag-ifltype-backw">$ref = swe_lun_eclipse_when($tjd_ut, $iflag, $ifltype, $backw);</h2>

<pre><code>  Finds the next lunar eclipse

  Input:  $tjd_ut  Julian day number, Universal Time
          $iflag   (specify ephemeris to be used, cf. swe_calc( ))
          $ifltype Eclipse type to be searched; 0 if any type of
                   eclipse is wanted
          $backw   Search backward in time

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or eclipse type
          -&gt; serr  Error string, on error only
          -&gt; tret  Array reference for array, which contains the values fo the
                   following hash members:
          -&gt; ecl_maximum      time of maximum eclipse (UT)
          -&gt; ecl_partial_begin
          -&gt; ecl_partial_end
          -&gt; ecl_total_begin
          -&gt; ecl_total_end
          -&gt; ecl_penumbral_begin
          -&gt; ecl_penumbral_end

  There are the following eclipse types for lunar eclipses:
  SE_ECL_TOTAL, SE_ECL_PENUMBRAL, SE_ECL_PARTIAL</code></pre>

<h2 id="ref-swe_lun_eclipse_when_loc-tjd_ut-iflag-backw-geopos">$ref = swe_lun_eclipse_when_loc($tjd_ut, $iflag, $backw, $geopos);</h2>

<p>Finds the next lunar eclipse</p>

<pre><code>  Input:  $tjd_ut  Julian day number, Universal Time
          $iflag   (specify ephemeris to be used, cf. swe_calc( ))
          $backw   Search backward in time
          $geopos      pointer to array of geogr. long., lat., height

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or eclipse type
          -&gt; serr  Error string, on error only
          -&gt; tret  Array reference for array, which contains the values fo the
                   following hash members:
          -&gt; ecl_maximum      time of maximum eclipse (UT)
          -&gt; ecl_partial_begin
          -&gt; ecl_partial_end
          -&gt; ecl_total_begin
          -&gt; ecl_total_end
          -&gt; ecl_penumbral_begin
          -&gt; ecl_penumbral_end
          -&gt; ecl_tmoonrise    time of moonrise during eclipse
          -&gt; ecl_tmoonset     time of moonset during eclipse
          -&gt; mag_umbral 
          -&gt; mag_penumbral 
          -&gt; moon_azimuth 
          -&gt; moon_alt_true
          -&gt; moon_alt_app
          -&gt; separation_angle

  There are the following eclipse types for lunar eclipses:
  SE_ECL_TOTAL, SE_ECL_PENUMBRAL, SE_ECL_PARTIAL</code></pre>

<h2 id="ref-swe_lun_eclipse_how-tjd_ut-iflag-geopos">$ref = swe_lun_eclipse_how($tjd_ut, $iflag, $geopos);</h2>

<p>Function calculates the local character of an eclipse.</p>

<pre><code>  Input:  $tjd_ut  Julian day number, Universal Time
          $iflag   (specify ephemeris to be used, cf. swe_calc( ))
          $geopos  Array reference for array of geograph. long., lat., height

  Output: $ref     hash reference, which contains:

          -&gt; retval            ERR or eclipse type
          -&gt; serr              Error string, on error only
          -&gt; attr              Array reference for array (s. Programmer&#39;s Manual)   
          -&gt; mag_umbral        Umbral magnitude
          -&gt; mag_penumbral     Penumbral magnitude
          -&gt; moon_azimuth 
          -&gt; moon_alt_true
          -&gt; moon_alt_app
          -&gt; separation_angle</code></pre>

<h2 id="ref-swe_lun_occult_when_glob-tjd_ut-ipl-star-iflag-ifltype-backw">$ref = swe_lun_occult_when_glob($tjd_ut, $ipl, $star, $iflag, $ifltype, $backw);</h2>

<pre><code>  Finds the next occultation of a celestial body by the moon,
  no matter where on earth.

  Input:  $tjd_ut  Julian day number, Universal Time
          $ipl     Planet occulted
          $star    Star name, if a star occultation is searched
          $iflag   (specify ephemeris to be used, cf. swe_calc( ))
          $ifltype Eclipse type to be searched; 0 if any type of
                   eclipse is wanted
          $backw   Search backward in time

  Output: $ref     hash reference, which contains:

          -&gt; retval     ERR or occultation type
          -&gt; serr  Error string, on error only
          -&gt; starname  Corrected star name
          -&gt; tret  Array reference for array, which contains the values fo the
                   following hash members:
          -&gt; occ_maximum      Time of maximum occultation (UT)
          -&gt; occ_local_noon   Occ. happens at local noon (UT)
          -&gt; occ_begin
          -&gt; occ_end
          -&gt; occ_total_begin
          -&gt; occ_total_end
          -&gt; occ_central_begin
          -&gt; occ_central_end

  There are the following eclipse types for lunar eclipses:
  SE_ECL_TOTAL, SE_ECL_PARTIAL, SE_ECL_CENTRAL, SE_ECL_NONCENTRAL</code></pre>

<h2 id="ref-swe_lun_occult_when_loc-tjd_ut-ipl-star-iflag-backw-geopos">$ref = swe_lun_occult_when_loc($tjd_ut, $ipl, $star, $iflag, $backw, $geopos);</h2>

<pre><code>  Finds the next solar eclipse for a given place on earth.

  Input:  $tjd_ut  Julian day number, Universal Time
          $ipl     Planet occulted
          $star    Star name, if a star occultation is searched
          $iflag   (specify ephemeris to be used, cf. swe_calc( ))
          $backw   Search backward in time
          $geopos  Array reference for array of geograph. long., lat., height

  Output: $ref     hash reference, which contains:

          -&gt; retval            ERR or eclipse type
          -&gt; serr              Error string, on error only
          -&gt; starname          Corrected star name
          -&gt; tret  Array reference for array (s. C Programmer&#39;s Manual)
          -&gt; attr  Array reference for array (s. C Programmer&#39;s Manual)
          -&gt; ecl_maximum       time of maximum occultation (UT)
          -&gt; t1st_contact
          -&gt; t2nd_contact
          -&gt; t3rd_contact
          -&gt; t4th_contact
          -&gt; disc_ratio        size ratio of the two discs
          -&gt; fraction_diameter percentage of diameter occulted
          -&gt; fraction_disc     percentage of disc occulted
          -&gt; core_shadow_km    diameter of core shadow (km, negative
                               with total, positive with annular ecl.)
          -&gt; body_azimuth
          -&gt; body_alt_true
          -&gt; separation_angle</code></pre>

<h2 id="ref-swe_lun_occult_where-tjd_ut-ipl-star-iflag">$ref = swe_lun_occult_where($tjd_ut, $ipl, $star, $iflag);</h2>

<pre><code>  Finds the place on earth where the occultation is maximal at a given
  time. 

  Input:  $tjd_ut  Julian day number, Universal Time
          $ipl     Planet occulted
          $star    Star name, if a star occultation is searched
          $iflag   (specify ephemeris to be used, cf. swe_calc( ))

  Output: $ref     hash reference, which contains:

          -&gt; retval            ERR or eclipse type
          -&gt; serr              Error string, on error only
          -&gt; starname          Corrected star name
          -&gt; attr              Array reference for array (s. Programmer&#39;s Manual)
          -&gt; geopos            Array reference for array, geogr. position
                               where eclipse is maximal
          -&gt; disc_ratio        size ratio of the two discs
          -&gt; fraction_diameter percentage of diameter occulted
          -&gt; fraction_disc     percentage of disc occulted
          -&gt; core_shadow_km    diameter of core shadow (km, negative
                               with total, positive with annular ecl.)
          -&gt; body_azimuth
          -&gt; body_alt_true
          -&gt; separation_angle
          -&gt; geo_long          (from geopos)
          -&gt; geo_lat           (from geopos)</code></pre>

<h1 id="Coordinate-Transformations">Coordinate Transformations</h1>

<h2 id="cout-swe_cotrans-cin-eps">@cout = swe_cotrans(\@cin, $eps);</h2>

<pre><code>  Function transforms polar coordinates from equator to ecliptic or 
  from ecliptic to equator.

  Input:  \@cin    Polar coordinates of point to be transformed;
                   reference to an array of 3 decimals. 
                   (e.g. longitude, latitude, distance)
          $eps     Ecliptic obliquity. 
                   Must be positive for transformation equator-&gt;ecliptic
                   Must be negative for transformation ecliptic-&gt;equator

  Output: @cout    Output coordinates; an array of 3 decimals.</code></pre>

<h2 id="cout-swe_cotrans_sp-cin-eps">@cout = swe_cotrans_sp(\@cin, $eps);</h2>

<pre><code>  Function does the same as swe_cotrans(), but in addition, it also 
  transforms the speed of a body to another coordinate system.  
  The input and output arrays have 6 decimals, 3 for the position 
  and 3 for the speed.  </code></pre>

<h2 id="ref-swe_azalt-tjd_ut-calcflag-geopos-atpress-attemp-xin">$ref = swe_azalt($tjd_ut, $calcflag, $geopos, $atpress, $attemp, $xin);</h2>

<pre><code>  Function calculates the azimuth and altitude from ecliptical or 
  equatorial coordinates.

  Input:  $tjd_ut   Julian day number, UT
          $calcflag either SE_ECL2HOR or SE_EQU2HOR
          $geopos   Array reference for array of geograph. long., lat., height
          $atpress  Atmospheric pressure in hPa (mbar)
          $attemp   Atmospheric temperature in degree C
          $xin      Array reference for array, position of body, either in 
                    equatorial or ecliptical polar coordinates, 
                    depending on $calcflag

  Output: @aret     array of (azimuth, true altitude, apparent altitude)</code></pre>

<h2 id="ref-swe_azalt_rev-tjd_ut-calcflag-geopos-atpress-attemp-xin">$ref = swe_azalt_rev($tjd_ut, $calcflag, $geopos, $atpress, $attemp, $xin);</h2>

<pre><code>  Function transforms azimuth and altitude to either ecliptical or 
  equatorial coordinates.

  Input:  $tjd_ut   Julian day number, UT
          $calcflag either SE_HOR2ECL or SE_HOR2EQU
          $geopos   Array reference for array of geograph. long., lat., height
          $xin      Array reference for array, azimuth and true altitude

  Output: @aret     either ecliptical or equatorial coordinates
  </code></pre>

<h1 id="Astrological-Houses">Astrological Houses</h1>

<h2 id="ref-swe_houses-tjd_ut-geolat-geolon-hsys">$ref = swe_houses($tjd_ut, $geolat, $geolon, $hsys);</h2>

<pre><code>  Function calculates the astrological houses and related stuff.

  Input:  $tjd_ut  Julian day number in UT
          $geolat  Geographical latitude
          $geolon  Geographical longitude
          $hsys    House system, a 1-char string; defaults to Placidus
                   (For more information, read the Swiss Ephemeris
                   Programmer&#39;s Manual.)

  Output: $ref     hash reference, which contains:

          -&gt;cusps  Array reference for an array: the twelve houses (cusps[1..12]).
          -&gt;ascmc  Array reference for an array: See the Programmer&#39;s Manual.
          -&gt;asc    Ascendant
          -&gt;mc     Midheaven (Medium Coeli)
          -&gt;armc   Right ascension of the midheaven
          -&gt;vertex Vertex
          -&gt;equasc &quot;equatorial ascendant&quot;
          -&gt;coasc1 &quot;co-ascendant 1&quot; (M. Munkasey)
          -&gt;coasc2 &quot;co-ascendant 2&quot; (M. Munkasey)
          -&gt;polasc &quot;polar ascendant&quot; (M. Munkasey)</code></pre>

<h2 id="ref-swe_houses_ex-tjd_ut-iflag-geolat-geolon-hsys">$ref = swe_houses_ex($tjd_ut, $iflag, $geolat, $geolon, $hsys);</h2>

<pre><code>  Function calculates the astrological houses and related stuff.
  The only difference from swe_houses( ) is that it has an
  additional input parameter $iflag, which allows for the calculation
  of houses for sidereal zodiacs. Set $iflag |= SEFLG_SIDEREAL.</code></pre>

<h2 id="ref-swe_houses_ex2-tjd_ut-iflag-geolat-geolon-hsys">$ref = swe_houses_ex2($tjd_ut, $iflag, $geolat, $geolon, $hsys);</h2>

<pre><code>  Like swe_houses_ex(), this function calculates the astrological houses and related stuff.
  The difference from swe_houses_ex( ) is that it provides the following

  additional output:
          -&gt;retval       0 if OK and -1 if error
          -&gt;serr         error message or warning, by default undefined
          -&gt;cusps_speed  Array reference for an array: speeds of twelve house cusps
          -&gt;ascmc_speed  Array reference for an array: See the Programmer&#39;s Manual.</code></pre>

<h2 id="ref-swe_houses_armc-tjd_ut-geolat-geolon-hsys">$ref = swe_houses_armc($tjd_ut, $geolat, $geolon, $hsys);</h2>

<pre><code>  Function calculates the astrological houses and related stuff, if 
  a date is not given, but a latitude and the right ascension of the
  midheaven.

  Input:  $armc    Right ascension of the Midheaven
          $geolat  Geographical latitude
          $eps     Obliquity of true ecliptic of date
          $hsys    House system, a 1-char string; cf. swe_houses( )

  Output: same as with swe_houses( )</code></pre>

<h2 id="ref-swe_houses_armc_ex2-tjd_ut-geolat-geolon-hsys">$ref = swe_houses_armc_ex2($tjd_ut, $geolat, $geolon, $hsys);</h2>

<pre><code>  Function does the same as swe_houses_armc_ex(), however 

  provides the following additional output:

          -&gt;retval       0 if OK and -1 if error
          -&gt;serr         error message or warning, by default undefined
          -&gt;cusps_speed  Array reference for an array: speeds of twelve house cusps
          -&gt;ascmc_speed  Array reference for an array: See the Programmer&#39;s Manual.</code></pre>

<h2 id="ref-swe_house_pos-armc-geolat-eps-hsys-ecl_lon-ecl_lat">$ref = swe_house_pos($armc, $geolat, $eps, $hsys, $ecl_lon, $ecl_lat);</h2>

<pre><code>  Function calculates the astrological house position of a planet or 
  other celestial point. 

  Input:  $armc    Right ascension of the Midheaven
          $geolat  Geographical latitude
          $eps     Obliquity of true ecliptic of date
          $hsys    House system, a 1-char string; cf. swe_houses( )
          $ecl_lon ecliptic longitude of body
          $ecl_lat ecliptic latitude of body

  Output: $ref     hash reference, which contains:

          -&gt;ihno   house number, integer
          -&gt;dhpos  house position, decimal between 1.0 and 12.9999
          -&gt;dhpos_deg  house position, degrees, between 0&deg; and 359.9999&deg;
          -&gt;serr   error string, on error only</code></pre>

<h2 id="hnam-swe_house_name-hsys">$hnam = swe_house_name($hsys);</h2>

<pre><code>  Function returns the name of the house method.
  Input:  $hsys    House system, a 1-char string; cf. swe_houses( )</code></pre>

<h2 id="ref-swe_gauquelin_sector-tjd_ut-ipl-star-iflag-imeth-geopos-atpress-attemp">$ref = swe_gauquelin_sector($tjd_ut, $ipl, $star, $iflag, $imeth, $geopos, $atpress, $attemp);</h2>

<pre><code>  Function calculates the Gauquelin sector position of a planet or other
  object.

  Input:  $tjd_ut   Julian day number, UT
          $ipl      planet number 
          $star     Star name (string), if star is being calculated
          $iflag    Ephemeris flag
          $imeth    Method flag
               0    use Placidus house position
               1    use Placidus house posiition (with planetary lat = 0)
               2    use rise and set of body&#39;s disc center
               3    use rise and set of body&#39;s disc center with refraction
          $geopos   Array reference for array of geograph. long., lat., height
          $atpress  Atmospheric pressure in hPa (mbar)
          $attemp   Atmospheric temperature in degree C

  Output: $ref      hash reference, which contains:

          -&gt;retval  OK or ERR
          -&gt;serr    Error string, on error only
          -&gt;dsector Gauquelin sector position of object
          -&gt;starname Star name, corrected</code></pre>

<h1 id="Refraction">Refraction</h1>

<h2 id="outalt-swe_refrac-inalt-atpress-attemp-calcflag">$outalt = swe_refrac($inalt, $atpress, $attemp, $calcflag);</h2>

<pre><code>  Function calculates true altitude from apparent altitude or
  apparent altitude from true altitude.

  Input:  $inalt    true or apparent altitude of a planet, depending
                    on $calcflag
          $atpress  Atmospheric pressure in hPa (mbar)
          $attemp   Atmospheric temperature in degree C
          $calcflag either SE_CALC_APP_TO_TRUE or SE_CALC_TRUE_TO_APP

  Output: $outalt   either apparent or true altitude of the planet,
                    depending on $calcflag

  For more detailed information, read the C Programmer&#39;s Manual.</code></pre>

<h2 id="ref-swe_refrac_extended-inalt-geoalt-atpress-attemp-lapserate-calcflag">$ref = swe_refrac_extended($inalt, $geoalt, $atpress, $attemp, $lapserate, $calcflag);</h2>

<pre><code>  Function calculates true altitude from apparent altitude or
  apparent altitude from true altitude.
  It does the same as swe_refrac(), but is more skilled. 
  (see C Programmer&#39;s Manual)

  Input:  $inalt    true or apparent altitude of a planet, depending
                    on $calcflag
          $geoalt   altitude of observer above sea level in meters
          $atpress  Atmospheric pressure in hPa (mbar)
          $attemp   Atmospheric temperature in degree C
          $lapserate (dT/dh) [&deg;K/m]
          $calcflag either SE_CALC_APP_TO_TRUE or SE_CALC_TRUE_TO_APP

  Output: $ref      hash reference, which contains:

          -&gt;retval  OK or ERR
          -&gt;serr    Error string, on error only
          -&gt;dret    Array reference for an array which contains the values of
                    the following hash members:
          -&gt;alt_true 
          -&gt;alt_apparent 
          -&gt;refraction
          -&gt;dip     Dip of the horizon 

  For more detailed information, read the C Programmer&#39;s Manual.</code></pre>

<h1 id="Heliacal-Phenomena">Heliacal Phenomena</h1>

<h2 id="ref-swe_heliacal_ut-tjd_start-dgeo-datm-dobs-objname-type_event-iflag">$ref = swe_heliacal_ut($tjd_start, $dgeo, $datm, $dobs, $objname, $type_event, $iflag)</h2>

<pre><code>  Function calls mornig first, morning last, evening first, or 
  evening last of a planet or fixed star.

  Input:  $tjd_start    start date for search
          $dgeo         array pointer (geogr. longitude, latitude, height)
          $datm         array pointer (atm. pressure, temperature, 
                        relative humidity, visibility/extinction coeffictient)
          $dobs         array pointer (observer age, Snellen ratio, 
                        is_binocular, telescope magnification, telescope
                        diameter, telescope transmission)
          $objname      string: object name
          $type_event   SE_HELIACAL_RISING (1)
                        SE_HELIACAL_SETTING (2)
                        SE_EVENING_FIRST (3)
                        SE_MORNING_LAST (4)
          $iflag        ephemeris flag, can be combined with the 
                        following flags:
                        SE_HELFLAG_LONG_SEARCH     search until found
                        SE_HELFLAG_HIGH_PRECISION  slower but preciser
                        SE_HELFLAG_NO_DETAILS      very fast, no details
                        SE_HELFLAG_OPTICAL_PARAMS  binocular/telescope
                        (for more info, please read the Swiss Ephemeris
                        Programmer&#39;s Manual swephprg.doc)

  Output: $ref      hash reference, which contains:

          -&gt;retval      OK or ERR
          -&gt;serr        error or warning message
          -&gt;tstart      start of visibility (jd)
          -&gt;topt        optimum visibility (jd)
          -&gt;tend        end of visibility (jd)
          -&gt;dret        array of doubles, contains tstart, topt, tend.</code></pre>

<h2 id="ref-swe_vis_limit_mag-tjd_start-dgeo-datm-dobs-objname-iflag">$ref = swe_vis_limit_mag($tjd_start, $dgeo, $datm, $dobs, $objname, $iflag)</h2>

<pre><code>  Function calculates magnitude limit for observation of a body under
  the specified conditions.

  Input:  same as with swe_heliacal_ut(), but type_event is missing.

  Output: $ref        hash reference, which contains:

          -&gt;retval    can have the following values:
                      -2        Object is below the horizon
                      -1 (ERR)  Error
                       0 (OK)   Ok, photopic vision
                       &amp;1       Ok, scotopic vision
                       &amp;2       Ok, near limit photopic/scotopic vision
          -&gt;serr      Error or warning message
          -&gt;dvislim   magnitude required for visibility
          -&gt;daltobj   altitude of object above horizon
          -&gt;daziobj   azimuth of object
          -&gt;daltsun   altitude of sun above horizon
          -&gt;dazisun   azimuth of moon
          -&gt;daltmoo   altitude of sun above horizon
          -&gt;dazimoo   azimuth of moon
          -&gt;dret      Array pointer, containing:
                      - magnitude limit
                      - altitudes and azimuts of object, Sun, and Moon.
  </code></pre>

<h1 id="Normalisation-to-360-and-Angles-between-Ecliptic-Points">Normalisation to 360&deg; and Angles between Ecliptic Points</h1>

<h2 id="ddeg-swe_degnorm-ddeg">$ddeg = swe_degnorm($ddeg);</h2>

<pre><code>  Function normalises a value, which is &lt;0&deg; or &gt;360&deg; to a value between
  0&deg; and 360&deg;.</code></pre>

<h2 id="drad-swe_radnorm-drad">$drad = swe_radnorm($drad);</h2>

<pre><code>  Function normalises a value, which is &lt;0 or &gt;2PI to a value between
  0 and 2PI.</code></pre>

<h2 id="ddeg-swe_difdegn-ddeg1-ddeg2">$ddeg = swe_difdegn($ddeg1, $ddeg2);</h2>

<pre><code>  Function returns the swe_degnorm($deg1 - ddeg2).</code></pre>

<h2 id="ddeg-swe_difdegn-ddeg1-ddeg21">$ddeg = swe_difdegn($ddeg1, $ddeg2);</h2>

<pre><code>  Function returns the swe_degnorm($deg1 - ddeg2).</code></pre>

<h2 id="ddeg-swe_difdeg2n-ddeg1-ddeg2">$ddeg = swe_difdeg2n($ddeg1, $ddeg2);</h2>

<pre><code>  Function returns the angle distance of $ddeg1 from $ddeg 2 as
  a value between -180&deg; and +180&deg;.</code></pre>

<h2 id="drad-swe_difrad2n-drad1-drad2">$drad = swe_difrad2n($drad1, $drad2);</h2>

<pre><code>  Function returns the angle distance of $drad1 from $drad 2 as
  a value between -PI and +PI.</code></pre>

<h2 id="ddeg-swe_deg_midp-ddeg1-ddeg2">$ddeg = swe_deg_midp($ddeg1, $ddeg2);</h2>

<pre><code>  Function returns the midpoint between the two positions.</code></pre>

<h2 id="drad-swe_rad_midp-drad1-drad2">$drad = swe_rad_midp($drad1, $drad2);</h2>

<pre><code>  Function returns the midpoint between the two positions, in radians.</code></pre>

<h2 id="ref-swe_split_deg-ddeg-splitflag">$ref swe_split_deg($ddeg, $splitflag);</h2>

<pre><code>  Function returns a hash with fields ideg, imin, isec, dfrc, isgn
  splitflag 
  SE_SPLIT_DEG_ROUND_SEC  1;
  SE_SPLIT_DEG_ROUND_MIN =&gt; 2;
  SE_SPLIT_DEG_ROUND_DEG =&gt; 4;
  SE_SPLIT_DEG_ZODIACAL  =&gt; 8;
  SE_SPLIT_DEG_KEEP_SIGN =&gt;16;   # don&#39;t round to next sign,
                                 # e.g. 29.9999999 will be rounded
                                 # to 29&deg;59&#39;59&quot; (or 29&deg;59&#39; or 29&deg;)
  SE_SPLIT_DEG_KEEP_DEG =&gt; 32 
  </code></pre>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<ul>

<li><p>Swiss Ephemeris homepage: https://www.astro.com/swisseph</p>

</li>
<li><p>Swiss Ephemeris Mailing list: swisseph@groups.io</p>

</li>
<li><p>Description of R&uuml;diger Plantiko&#39;s Perl wrapper for the Swiss Ephemeris (in german language): http://www.astrotexte.ch/sources/swe_perl.html</p>

</li>
<li><p>Perl XS documentation: perlxs, perlxstuts, perlguts, perlapi</p>

</li>
</ul>

<h1 id="AUTHORS">AUTHORS</h1>

<p>Dieter Koch and Alois Treindl, Astrodienst, Z&uuml;rich, Switzerland</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<h2 id="License-conditions">License conditions</h2>

<p>Copyright of this Perl Port (C) 2021 by Astrodienst AG, Switzerland. All rights reserved.</p>

<p>This file is part of Swiss Ephemeris.</p>

<p>Swiss Ephemeris is distributed with NO WARRANTY OF ANY KIND. No author or distributor accepts any responsibility for the consequences of using it, or for whether it serves any particular purpose or works at all, unless he or she says so in writing.</p>

<p>Swiss Ephemeris is made available by its authors under a dual licensing system. The software developer, who uses any part of Swiss Ephemeris in his or her software, must choose between one of the two license models, which are a) GNU Affero General Public License (AGPL) b) Swiss Ephemeris Professional License</p>

<p>The choice must be made before the software developer distributes software containing parts of Swiss Ephemeris to others, and before any public service using the developed software is activated.</p>

<p>If the developer choses the AGPL software license, he or she must fulfill the conditions of that license, which includes the obligation to place his or her whole software project under the AGPL or a compatible license. See https://www.gnu.org/licenses/agpl-3.0.html</p>

<p>If the developer choses the Swiss Ephemeris Professional license, he must follow the instructions as found in http://www.astro.com/swisseph/ and purchase the Swiss Ephemeris Professional Edition from Astrodienst and sign the corresponding license contract.</p>

<p>The License grants you the right to use, copy, modify and redistribute Swiss Ephemeris, but only under certain conditions described in the License. Among other things, the License requires that the copyright notices and this notice be preserved on all copies.</p>

<p>Authors of the Swiss Ephemeris: Dieter Koch and Alois Treindl</p>

<p>The authors of Swiss Ephemeris have no control or influence over any of the derived works, i.e. over software or services created by other programmers which use Swiss Ephemeris functions.</p>

<p>The names of the authors or of the copyright holder (Astrodienst) must not be used for promoting any software, product or service which uses or contains the Swiss Ephemeris. This copyright notice is the ONLY place where the names of the authors can legally appear, except in cases where they have given special permission in writing.</p>

<p>The trademarks &#39;Swiss Ephemeris&#39; and &#39;Swiss Ephemeris inside&#39; may be used for promoting such software, products or services.</p>


</body>

</html>


